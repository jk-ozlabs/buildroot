diff -Naur ipmitool-source.orig/configure.ac ipmitool-source/configure.ac
--- ipmitool-source.orig/configure.ac	2015-03-20 19:35:18.358090617 -0400
+++ ipmitool-source/configure.ac	2015-03-20 15:53:31.831648557 -0400
@@ -196,6 +196,21 @@
 	AC_SUBST(INTF_LAN_LIB, [libintf_lan.la])
 	IPMITOOL_INTF_LIB="$IPMITOOL_INTF_LIB lan/libintf_lan.la"
 fi
+dnl enable IPMI USB interface
+AC_ARG_ENABLE([intf-usb],
+	[AC_HELP_STRING([--enable-intf-usb],
+			[enable IPMI USB interface [default=yes]])],
+	    [xenable_intf_usb=$enableval], 
+        [xenable_intf_usb=yes])
+if test "x$xenable_intf_usb" = "xstatic" || test "x$xenable_intf_usb" = "xplugin"; then
+   xenable_intf_usb=yes
+fi
+if test "x$xenable_intf_usb" = "xyes";then
+    AC_DEFINE(IPMI_INTF_USB, [1], [Define to 1 to enable USB interface.])
+    AC_SUBST(INTF_USB, [usb])
+    AC_SUBST(INTF_USB_LIB, [libintf_usb.la])
+    IPMITOOL_INTF_LIB="$IPMITOOL_INTF_LIB usb/libintf_usb.la"
+fi
 
 dnl enable IPMIv2.0 RMCP+ LAN interface
 AC_ARG_ENABLE([intf-lanplus],
@@ -638,6 +653,7 @@
 		src/plugins/free/Makefile
 		src/plugins/imb/Makefile
 		src/plugins/bmc/Makefile
+		src/plugins/usb/Makefile
 		src/plugins/lipmi/Makefile
 		src/plugins/serial/Makefile
 		src/plugins/dummy/Makefile])
@@ -654,6 +670,7 @@
 AC_MSG_RESULT([  free    : $xenable_intf_free])
 AC_MSG_RESULT([  imb     : $xenable_intf_imb])
 AC_MSG_RESULT([  bmc     : $xenable_intf_bmc])
+AC_MSG_RESULT([  usb     : $xenable_intf_usb])
 AC_MSG_RESULT([  lipmi   : $xenable_intf_lipmi])
 AC_MSG_RESULT([  serial  : $xenable_intf_serial])
 AC_MSG_RESULT([  dummy   : $xenable_intf_dummy])
diff -Naur ipmitool-source.orig/lib/ipmi_hpmfwupg.c ipmitool-source/lib/ipmi_hpmfwupg.c
--- ipmitool-source.orig/lib/ipmi_hpmfwupg.c	2015-03-20 19:35:18.366090617 -0400
+++ ipmitool-source/lib/ipmi_hpmfwupg.c	2015-03-20 15:54:14.518465931 -0400
@@ -1199,7 +1199,7 @@
 			} else {
 				count = (unsigned short)((pDataTemp+lengthOfBlock) - pData);
 			}
-			memcpy(&uploadCmd.req->data, pData, bufLength);
+			memcpy(&uploadCmd.req->data, pData, count);
 			imageOffset = 0x00;
 			blockLength = 0x00;
 			numTxPkts++;
diff -Naur ipmitool-source.orig/src/plugins/ipmi_intf.c ipmitool-source/src/plugins/ipmi_intf.c
--- ipmitool-source.orig/src/plugins/ipmi_intf.c	2015-03-20 19:35:18.374090617 -0400
+++ ipmitool-source/src/plugins/ipmi_intf.c	2015-03-20 15:54:02.633777209 -0400
@@ -85,6 +85,9 @@
 #ifdef IPMI_INTF_DUMMY
 extern struct ipmi_intf ipmi_dummy_intf;
 #endif
+#ifdef IPMI_INTF_USB
+extern struct ipmi_intf ipmi_usb_intf;
+#endif
 
 struct ipmi_intf * ipmi_intf_table[] = {
 #ifdef IPMI_INTF_OPEN
@@ -115,6 +118,9 @@
 #ifdef IPMI_INTF_DUMMY
 	&ipmi_dummy_intf,
 #endif
+#ifdef IPMI_INTF_USB
+	&ipmi_usb_intf,
+#endif
 	NULL
 };
 
@@ -474,7 +480,7 @@
 uint16_t
 ipmi_intf_get_max_request_data_size(struct ipmi_intf * intf)
 {
-	int16_t size;
+	uint16_t size;
 
 	size = intf->max_request_data_size;
 
@@ -531,7 +537,7 @@
 uint16_t
 ipmi_intf_get_max_response_data_size(struct ipmi_intf * intf)
 {
-	int16_t size;
+	uint16_t size;
 
 	size = intf->max_response_data_size;
 
diff -Naur ipmitool-source.orig/src/plugins/Makefile.am ipmitool-source/src/plugins/Makefile.am
--- ipmitool-source.orig/src/plugins/Makefile.am	2015-03-20 19:35:18.374090617 -0400
+++ ipmitool-source/src/plugins/Makefile.am	2015-03-20 15:53:48.310572692 -0400
@@ -32,8 +32,8 @@
 
 INCLUDES			= -I$(top_srcdir)/include
 
-SUBDIRS				= @INTF_LAN@ @INTF_LANPLUS@ @INTF_OPEN@ @INTF_LIPMI@ @INTF_IMB@ @INTF_BMC@ @INTF_FREE@ @INTF_SERIAL@ @INTF_DUMMY@
-DIST_SUBDIRS			= lan lanplus open lipmi imb bmc free serial dummy
+SUBDIRS				= @INTF_LAN@ @INTF_LANPLUS@ @INTF_OPEN@ @INTF_LIPMI@ @INTF_IMB@ @INTF_BMC@ @INTF_FREE@ @INTF_USB@ @INTF_SERIAL@ @INTF_DUMMY@
+DIST_SUBDIRS			= lan lanplus open lipmi imb bmc free usb serial dummy
 
 noinst_LTLIBRARIES		= libintf.la
 libintf_la_SOURCES		= ipmi_intf.c
diff -Naur ipmitool-source.orig/src/plugins/usb/Makefile.am ipmitool-source/src/plugins/usb/Makefile.am
--- ipmitool-source.orig/src/plugins/usb/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ ipmitool-source/src/plugins/usb/Makefile.am	2015-03-20 19:43:16.366089359 -0400
@@ -0,0 +1,39 @@
+# Copyright (c) 2003 Sun Microsystems, Inc.  All Rights Reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 
+# Redistribution of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer.
+# 
+# Redistribution in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution.
+# 
+# Neither the name of Sun Microsystems, Inc. or the names of
+# contributors may be used to endorse or promote products derived
+# from this software without specific prior written permission.
+# 
+# This software is provided "AS IS," without a warranty of any kind.
+# ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND WARRANTIES,
+# INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A
+# PARTICULAR PURPOSE OR NON-INFRINGEMENT, ARE HEREBY EXCLUDED.
+# SUN MICROSYSTEMS, INC. ("SUN") AND ITS LICENSORS SHALL NOT BE LIABLE
+# FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING
+# OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.  IN NO EVENT WILL
+# SUN OR ITS LICENSORS BE LIABLE FOR ANY LOST REVENUE, PROFIT OR DATA,
+# OR FOR DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL OR
+# PUNITIVE DAMAGES, HOWEVER CAUSED AND REGARDLESS OF THE THEORY OF
+# LIABILITY, ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE,
+# EVEN IF SUN HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+MAINTAINERCLEANFILES	= Makefile.in
+
+INCLUDES		= -I$(top_srcdir)/include
+
+EXTRA_LTLIBRARIES	= libintf_usb.la
+noinst_LTLIBRARIES	= @INTF_USB_LIB@
+libintf_usb_la_LIBADD	= $(top_builddir)/lib/libipmitool.la
+libintf_usb_la_SOURCES	= usb.c
+
diff -Naur ipmitool-source.orig/src/plugins/usb/usb.c ipmitool-source/src/plugins/usb/usb.c
--- ipmitool-source.orig/src/plugins/usb/usb.c	1969-12-31 19:00:00.000000000 -0500
+++ ipmitool-source/src/plugins/usb/usb.c	2015-03-20 19:43:16.386089359 -0400
@@ -0,0 +1,647 @@
+/******************************************************************
+ ******************************************************************
+ ***                                                                                                           **
+ ***    (C)Copyright 2012,American Megatrends Inc.                                      **
+ ***                                                                                                           **
+ ***    All Rights Reserved.                                                                          **
+ ***                                                                                                           **
+ ***    5555 , Oakbrook Pkwy, Norcross,                                                       **
+ ***                                                                                                           **
+ ***    Georgia - 30093, USA. Phone-(770)-246-8600.                                  **
+ ***                                                                                                           **
+ ******************************************************************
+ ******************************************************************
+ ******************************************************************
+ *
+ * usb.c
+ * usb related Functions.
+ *
+ *  Author: Winston <winstont@ami.com>
+ ******************************************************************/
+
+#include <ipmitool/helper.h>
+#include <ipmitool/log.h>
+#include <ipmitool/bswap.h>
+#include <ipmitool/ipmi.h>
+#include <ipmitool/ipmi_intf.h>
+#include <ipmitool/ipmi_oem.h>
+#include <ipmitool/ipmi_strings.h>
+#include <ipmitool/ipmi_constants.h>
+#include <scsi/sg.h>
+#include <sys/ioctl.h>
+#include <scsi/scsi_ioctl.h>
+#include <scsi/scsi.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#define PACKED __attribute__ ((packed))
+#define BEGIN_SIG   "$G2-CONFIG-HOST$"
+#define BEGIN_SIG_LEN 16
+#define	MAX_REQUEST_SIZE		64 * 1024//1024 * 60
+#define CMD_RESERVED        0x0000 
+#define SCSI_AMICMD_CURI_WRITE			 	0xE2
+#define SCSI_AMICMD_CURI_READ				0xE3
+#define SCSI_AMIDEF_CMD_SECTOR				0x01
+#define SCSI_AMIDEF_DATA_SECTOR				0x02
+#define ERR_SUCCESS     0       /* Success */
+#define ERR_BIG_DATA    1       /* Too Much Data */
+#define ERR_NO_DATA     2       /* No/Less Data Available */
+#define ERR_UNSUPPORTED 3       /* Unsupported Command */
+#define IN_PROCESS 0x8000       /* Bit 15 of Status */
+
+/* SCSI Command Packets */
+typedef struct
+{
+	unsigned char		OpCode;
+	unsigned char		Lun;
+	unsigned int		Lba;
+	union
+	{
+		struct
+		{
+			unsigned char		Reserved6;
+			unsigned short		Length;
+			unsigned char		Reserved9[3];
+		} PACKED Cmd10;
+		struct Len32
+		{
+			unsigned int		Length32;
+			unsigned char		Reserved10[2];
+		} PACKED Cmd12;
+	} PACKED CmdLen;
+}PACKED SCSI_COMMAND_PACKET;
+
+typedef struct {
+	uint8_t	byNetFnLUN;
+	uint8_t	byCmd;
+	uint8_t	byData[64 * 1024];
+}PACKED IPMIUSBRequest_T;
+
+typedef struct
+{
+    uint8_t   BeginSig[BEGIN_SIG_LEN];
+    uint16_t  Command;
+    uint16_t  Status;
+    uint32_t  DataInLen;          /* Sent to us       */
+    uint32_t  DataOutLen;         /* Sent by us       */
+    uint32_t  InternalUseDataIn;
+    uint32_t  InternalUseDataOut;
+ } CONFIG_CMD;
+
+#define SCSI_AMICMD_ID					0xEE
+
+static int ipmi_usb_setup(struct ipmi_intf * intf);
+static struct ipmi_rs * ipmi_usb_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req);
+
+struct ipmi_intf ipmi_usb_intf = {
+	name:		"usb",
+	desc:		"IPMI USB Interface",
+	setup:		ipmi_usb_setup,
+	sendrecv:	ipmi_usb_send_cmd,
+};
+
+int scsiProbeNew(int* num_ami_devices,int* sg_nos)
+{
+	int inplen = *num_ami_devices;
+	int numdevfound = 0;
+	char linebuf[81];
+	char vendor[81];
+	int lineno = 0;
+	
+	//we will actuallyuse proc/scsi/sg/device_strs to find us
+
+	FILE* fp;
+#if 0
+	if(CheckGenericDevice()==-1)
+	{
+		*num_ami_devices = 0;
+		return 1;
+	}
+#endif
+	fp = fopen("/proc/scsi/sg/device_strs","r");
+	if(fp == NULL)
+	{
+		goto outnew;
+	}
+
+	while(1)
+	{
+		//ok now read line by line but we need to read only 3 	characters for
+		//finding AMI..
+		if(fgets(linebuf,80,fp) == NULL)
+		{
+			goto outnew;
+		}
+		
+		//otherwise we have a line in linebuf
+		sscanf(linebuf,"%s",vendor);
+		if(strncmp(vendor,"AMI",strlen("AMI")) == 0)
+		{
+			numdevfound++;
+			sg_nos[numdevfound -1] = lineno;
+			if(numdevfound == inplen)
+			{	
+				goto outnew;
+			} 
+		}
+		lineno++;
+	}
+outnew:
+	*num_ami_devices = numdevfound;
+	if(fp != NULL)
+		fclose(fp);
+	if(numdevfound == 0)
+		return 1;
+	else 
+		return 0;
+}
+
+int OpenCD(struct ipmi_intf *intf,char *CDName)
+{
+//	strcpy(CDName,"/dev/sg1");
+	//DEBUG_PRINTF("OpenCD: Opening AMI Virtual CD at %s\n", CDName);
+	intf->fd = open(CDName, O_RDWR);
+	if(intf->fd == -1) 
+	{
+		lprintf(LOG_ERR,"OpenCD:Unable to open the device, %s\n",strerror(errno));
+		return 1;
+	}
+	return 0;
+}
+
+int sendscsicmd_SGIO(int cd_desc, unsigned char* cdb_buf,unsigned char cdb_len,
+			void* data_buf,unsigned int* data_len,
+			int direction,
+			void* sense_buf,unsigned char slen,
+			unsigned int timeout)
+{
+	sg_io_hdr_t io_hdr;
+
+    /* Prepare command */
+	memset(&io_hdr, 0, sizeof(sg_io_hdr_t));
+        io_hdr.interface_id = 'S';
+
+	//io_hdr.cmd_len = cdb_len;
+	io_hdr.cmd_len = cdb_len;
+
+	/* io_hdr.iovec_count = 0; */  /* memset takes care of this */
+
+	/*transfer direection and length*/
+	io_hdr.dxfer_direction = direction;
+   	io_hdr.dxfer_len = *data_len;
+
+	/*data buffer to hold data*/
+	io_hdr.dxferp = data_buf;
+
+	/*where is the command*/
+	io_hdr.cmdp = cdb_buf;
+
+	/*sense buffer*/
+	io_hdr.sbp = (unsigned char *)sense_buf;
+        io_hdr.mx_sb_len = slen; /*we dont want sense info*/
+
+	/*timeout*/
+	io_hdr.timeout = timeout;
+	
+	if(!timeout)
+		io_hdr.timeout = 20000;
+
+	if (ioctl(cd_desc,SG_IO,&io_hdr) < 0)
+	{
+	        lprintf(LOG_ERR,"sendscsicmd_SGIO:  SG_IO ioctl error\n");
+        	return 1;
+   	}
+	else
+	{
+	       if(io_hdr.status != 0) 
+	       {
+		   	return 1;
+	       }
+	}
+
+	/* RESET THE CARD CASE */
+	if(!timeout)
+		return 0;
+
+	if ((io_hdr.info & SG_INFO_OK_MASK) != SG_INFO_OK)
+	{
+//       	DEBUG_PRINTF("sendscsicmd_SGIO: No OK\n");
+	}
+	else
+	{
+//		DEBUG_PRINTF("sendscsicmd_SGIO : OK GOT!!\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+int AMI_SPT_CMD_Identify(int cd_desc, char* szSignature)
+{
+	SCSI_COMMAND_PACKET IdPkt = {0};
+	int ret;
+	unsigned int siglen = 10;
+
+	IdPkt.OpCode 	   = SCSI_AMICMD_ID;
+	ret = sendscsicmd_SGIO(cd_desc, (unsigned char*)&IdPkt,
+				10,szSignature,&siglen,SG_DXFER_FROM_DEV,
+				NULL,0,5000);
+
+	return ret;
+}
+
+int IsG2Drive(int cd_desc)
+{
+    char szSignature[15];
+    int ret;
+
+    memset(szSignature, 0, 15);
+
+    flock(cd_desc,LOCK_EX);
+    ret = AMI_SPT_CMD_Identify(cd_desc, szSignature);
+    flock(cd_desc,LOCK_UN);
+    if ( ret != 0 ) 
+    {
+        lprintf(LOG_ERR,"IsG2Drive:Unable to send ID command to the device\n");
+        return 1;
+    }
+
+    if ( strncmp( szSignature, "$$$AMI$$$",strlen("$$$AMI$$$")) != 0 ) \
+    {
+        lprintf(LOG_ERR,"IsG2Drive:Signature mismatch when ID command is sent\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+int FindG2CDROM(struct ipmi_intf *intf)
+{
+	int err = 0;
+	char device[256];
+	int devarray[8];
+	int numdev = 8;
+	int iter;
+	//err = scsiProbe(0,device);
+	err = scsiProbeNew(&numdev,devarray);
+	if(err == 0 && numdev > 0)
+	{
+		for(iter =0;iter < numdev;iter++)
+		{
+			sprintf(device,"/dev/sg%d",devarray[iter]);
+		/* Success */
+		if(!OpenCD(intf,device))
+		{
+			/* Success */
+			if (!IsG2Drive(intf->fd))
+			{
+			       //printf("USB Device found \n");
+				/* Success */
+				return 1;
+			}
+			close(intf->fd);
+			}
+		}
+	}
+	else
+	{
+		//DEBUG_PRINTF("\nUnable to find Virtual CDROM Device\n");
+	}
+}
+
+static int ipmi_usb_setup(struct ipmi_intf * intf)
+{
+    if(FindG2CDROM(intf) == 0)
+    {
+        lprintf(LOG_ERR,"Error in USB session setup \n");
+        return -1;
+    }
+    intf->opened = 1;
+    return 0;
+}
+
+void InitCmdHeader(CONFIG_CMD* pG2CDCmdHeader)
+{
+    memset(pG2CDCmdHeader,0,sizeof(CONFIG_CMD));
+    strncpy((char*)pG2CDCmdHeader->BeginSig,BEGIN_SIG,BEGIN_SIG_LEN);
+}
+
+int AMI_SPT_CMD_SendCmd(int cd_desc, char *Buffer, char type, uint16_t buflen, unsigned int timeout)
+{
+	SCSI_COMMAND_PACKET	Cmdpkt;
+	char 			sensebuff[32];
+	int 			ret;
+	unsigned int	pktLen;
+    int             count = 3;
+    
+	memset(&Cmdpkt, 0, sizeof(SCSI_COMMAND_PACKET) );
+
+	Cmdpkt.OpCode	= SCSI_AMICMD_CURI_WRITE;
+	Cmdpkt.Lba	= htonl( type );
+	Cmdpkt.CmdLen.Cmd10.Length = htons(1);
+
+	pktLen = buflen;
+    while(count > 0)
+    {
+    	ret = sendscsicmd_SGIO(cd_desc,(unsigned char*)&Cmdpkt,
+				10,Buffer,&pktLen,SG_DXFER_TO_DEV,
+				sensebuff,32,timeout);
+        count--;
+        if(ret == 0) break;
+        else ret = -1;
+    }
+
+	return ret;
+}
+
+int AMI_SPT_CMD_RecvCmd(int cd_desc, char *Buffer, char type, uint16_t buflen)
+{
+	SCSI_COMMAND_PACKET	Cmdpkt;
+	char 			sensebuff[32];
+	int 			ret;
+	unsigned int	pktLen;
+    int             count = 3;
+
+	memset(&Cmdpkt, 0, sizeof(SCSI_COMMAND_PACKET) );
+	
+	Cmdpkt.OpCode	= SCSI_AMICMD_CURI_READ;
+	Cmdpkt.Lba	= htonl( type );
+	Cmdpkt.CmdLen.Cmd10.Length = htons(1);
+	
+	pktLen = buflen;
+	while (count > 0)
+	{
+		ret = sendscsicmd_SGIO(cd_desc, (unsigned char*)&Cmdpkt,
+					10,Buffer,&pktLen,SG_DXFER_FROM_DEV,
+					sensebuff,32,5000);
+		count--;
+		if (0 == ret) break;
+		else ret = -1;
+	}
+	
+	return ret;
+}
+
+int ReadCD(int cd_desc,char CmdData, char *Buffer,uint32_t DataLen)
+{
+    int ret;
+
+    ret = AMI_SPT_CMD_RecvCmd(cd_desc, Buffer, CmdData,DataLen );  
+
+    if ( ret != 0 ) 
+    {
+        lprintf(LOG_ERR,"Error while reading CD-Drive\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+int WriteCD(int cd_desc,char CmdData, char *Buffer, unsigned int timeout,uint32_t DataLen)
+{
+    int ret;
+
+    ret = AMI_SPT_CMD_SendCmd(cd_desc, Buffer, CmdData,DataLen ,timeout);  
+    if ( ret != 0 ) 
+    {
+        lprintf(LOG_ERR,"Error while writing to CD-Drive\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+int WriteSplitData(struct ipmi_intf *intf, char* Buffer,char Sector, uint32_t NumBytes, uint32_t timeout)
+{
+    uint32_t BytesWritten = 0;
+    int retVal;
+
+    if(NumBytes == 0) return 0;
+
+    while(BytesWritten < NumBytes)
+    {
+        if((retVal = WriteCD(intf->fd, Sector, (Buffer + BytesWritten),timeout,NumBytes)) != 0)
+        {
+            return retVal;
+        }
+
+        BytesWritten += NumBytes; 
+    }
+
+    return 0;
+}
+
+int ReadSplitData(struct ipmi_intf *intf, char* Buffer, char Sector, uint32_t NumBytes)
+{
+    uint32_t BytesRead = 0;
+
+    if(NumBytes == 0) return 0;
+
+    while(BytesRead < NumBytes)
+    {
+        if(ReadCD(intf->fd, Sector,(Buffer+BytesRead),NumBytes) == -1)
+        {
+            return 1;
+        }
+        BytesRead += NumBytes; 
+    }
+
+    return 0;
+}
+
+
+int WaitForCommandCompletion(struct ipmi_intf *intf,CONFIG_CMD* pG2CDCmdHeader,uint32_t timeout,uint32_t DataLen) 
+{
+    uint32_t TimeCounter = 0;
+
+    do
+    {
+
+        if(ReadCD(intf->fd, SCSI_AMIDEF_CMD_SECTOR,(char*)(pG2CDCmdHeader),DataLen) == -1)
+        {
+            lprintf(LOG_ERR,"ReadCD returned ERROR\n");
+            return 1;
+        }
+
+        if(pG2CDCmdHeader->Status & IN_PROCESS)
+        {
+
+        usleep(1000);
+        if(timeout >= 0)
+        {
+            TimeCounter++;
+            if(TimeCounter == (timeout+1)) /*timeout+1 because we have already checked..so we honor atcual timeout by comparing to +1*/
+            {
+                return 2; /*different condition for timeout*/
+            }
+        }
+        }
+        else
+        {
+            //DEBUG_PRINTF("Command completed\n");
+            break;
+        }
+    }
+    while(1);
+
+    return 0;
+}
+
+int SendDataToUSBDriver(struct ipmi_intf *intf, char *ReqBuffer, unsigned int ReqBuffLen, unsigned char *ResBuffer, unsigned int *ResBuffLen, unsigned int timeout)
+{
+    char CmdHeaderBuffer[sizeof(CONFIG_CMD)];
+    int retVal;
+    int waitretval = 0;
+    unsigned int to = 0;
+    uint32_t DataLen = 0; 
+
+    CONFIG_CMD* pG2CDCmdHeader = (CONFIG_CMD*)CmdHeaderBuffer;
+
+    /*FillHeader*/
+    InitCmdHeader(pG2CDCmdHeader);
+
+    /*Set command number*/
+    pG2CDCmdHeader->Command = CMD_RESERVED; /* HARD CODED */
+
+    /*Fill Lengths*/
+    pG2CDCmdHeader->DataOutLen = *ResBuffLen;
+    pG2CDCmdHeader->DataInLen = ReqBuffLen;
+
+    if(!timeout)
+    {
+        to = 3000;
+    }
+    DataLen = sizeof(CONFIG_CMD); 
+
+    /* Replace WriteCD for Linux here */
+    if(WriteCD(intf->fd, SCSI_AMIDEF_CMD_SECTOR, (char*)(pG2CDCmdHeader),to,DataLen) == -1)
+    {
+        lprintf(LOG_ERR,"Error in Write CD of SCSI_AMIDEF_CMD_SECTOR \n");
+        return -1;
+    }
+
+    /***Write the data to hard disk***/
+    if((retVal = WriteSplitData(intf,ReqBuffer, SCSI_AMIDEF_DATA_SECTOR, ReqBuffLen,timeout)) != 0) 
+    {
+        if(retVal == -1) 
+        {
+            lprintf(LOG_ERR,"Error in WriteSplitData of SCSI_AMIDEF_DATA_SECTOR \n");
+            return retVal;
+        }
+
+        lprintf(LOG_ERR,"Error in WriteSplitData of SCSI_AMIDEF_DATA_SECTOR \n");
+        return -1;
+    }
+
+    if(!timeout)
+    {
+        return 0;
+    }
+
+
+    /*Read Status now*/
+    waitretval = WaitForCommandCompletion(intf,pG2CDCmdHeader,timeout,DataLen);  
+    if(waitretval != 0)
+    {
+        //printf("waitforcmdcomplete failed\n");
+        lprintf(LOG_ERR,"waitforcmdcomplete failed\n");
+        return (0-waitretval);
+    }
+    else
+    {
+        //DEBUG_PRINTF("WaitForCommandCompletion SUCCESS\n");
+    }
+
+    switch(pG2CDCmdHeader->Status)
+    {
+        case ERR_SUCCESS:
+        {
+            *ResBuffLen = pG2CDCmdHeader->DataOutLen;
+
+            //printf("Before ReadSplitData %x \n",*ResBuffLen);
+            if(ReadSplitData(intf,(char *)ResBuffer, SCSI_AMIDEF_DATA_SECTOR, pG2CDCmdHeader->DataOutLen) != 0) 
+            {
+                printf("Error in ReadSplitData of SCSI_AMIDEF_DATA_SECTOR \n");
+                lprintf(LOG_ERR,"Error in ReadSplitData of SCSI_AMIDEF_DATA_SECTOR \n");
+                return -1;
+            }
+
+            /*a read at the end to see if read of data itself had any problems*/
+            /*this read verifies that the previous read above was ok*/
+            DataLen = sizeof(CONFIG_CMD); 
+            ReadCD(intf->fd, SCSI_AMIDEF_CMD_SECTOR,(char*)(pG2CDCmdHeader),DataLen); 
+
+            break;
+        }
+        case ERR_BIG_DATA:
+            //printf("Too much data\n");
+            lprintf(LOG_ERR,"Too much data\n");
+            break;
+        case ERR_NO_DATA:
+            //printf("Too little data\n");
+            lprintf(LOG_ERR,"Too little data\n");
+            break;
+        case ERR_UNSUPPORTED:
+            //printf("Unsupported command\n");
+            lprintf(LOG_ERR,"Unsupported command\n");
+            break;
+        default:
+           //printf("Unknown status\n");
+            lprintf(LOG_ERR,"Unknown status\n");
+    }
+
+    //printf("successful completion of SendDataToUSBDriver \n");
+    return pG2CDCmdHeader->Status;
+}
+
+
+
+static struct ipmi_rs * ipmi_usb_send_cmd(struct ipmi_intf * intf, struct ipmi_rq * req)
+{
+    static struct ipmi_rs rsp;
+    long timeout = 20000;
+    uint8_t byRet = 0;
+    char ReqBuff[MAX_REQUEST_SIZE] = {0};
+    IPMIUSBRequest_T* pReqPkt = (IPMIUSBRequest_T*)ReqBuff;
+    int retries = 0;
+
+    /********** FORM IPMI PACKET *****************/
+    pReqPkt->byNetFnLUN = req->msg.netfn << 2;
+    pReqPkt->byNetFnLUN += req->msg.lun; //needs to be checked
+    pReqPkt->byCmd = req->msg.cmd;
+    if(req->msg.data_len)
+        memcpy(pReqPkt->byData, req->msg.data, req->msg.data_len);
+    
+    /********** SEND DATA TO USB ******************/
+    while (retries < 3)
+    {
+        retries++;
+        byRet = SendDataToUSBDriver(intf,
+                            ReqBuff, 2 + req->msg.data_len,
+                            rsp.data, &rsp.data_len,timeout);
+
+        if (byRet == 0) break;
+
+    }
+    if (retries == 3)
+    {
+        lprintf(LOG_ERR,"Error while sending command using SendDataToUSBDriver\n");
+        rsp.ccode = byRet;
+        return &rsp;//STATUS_CODE(MEDIUM_ERROR_FLAG, byRet);
+    }
+
+    rsp.ccode = rsp.data[0];
+
+    /* save response data for caller */
+    if (rsp.ccode == 0 && rsp.data_len > 0) {
+        memmove(rsp.data, rsp.data + 1, rsp.data_len-1);
+        rsp.data[rsp.data_len] = 0;
+        rsp.data_len -= 1;
+    }
+    
+    return &rsp;
+}
+
